				Как влияет перегрузка и переопределение на сигнатуру метода.
	Метод считается перегруженным если существует несколько его версий с одним именем и разным списком параметров.
Статические методы могут перегружаться нестатическими и наоборот без ограничений.
Перегрузка метода осуществляется в рамках одного класса.
Перегрузка осуществляеться когда сигнатура разная а переопределение только с одинаковой сигнатурой.
Пример:
	Public class TestOverloads {
	
	public void test(){} // Изначальный метод test
	
	void test (int b){} //перегружен добавили сигнатуру int при этом неважно что в нем изменился модификатор доступа
	
	Public void test (Strinjg a){}// изменили в сигнатуре тип параметра на String поэтому это уже другая перегрузка
	
	public void test (String a, int b){}// перегрузили добавили в сигнатуру два параметра
	
	public void test (String a, int b, double c){}//здесь уже три параметра

	protected object test (object i) {return null}// поменяли тип параметра на Object но перегрузка серавно будет работать


	Важно помнить что последовательность параметров имеет значние.

	как делать нельзя:
	
	public boolean test() {return false}// ошибка в том что поменялся тип возвращаемых данных сигнатура не менялась
	
	private void test (String a){}//сигнатура уже совпадает с верхней перегрузкой.. смена модификатора не имеет никакого значения

	pablic void test (String abc, int num){}//не верно название параметров не имеет никакого значения при перегрузке.. сигнатура осталась та-же что и в примере выше точнее такие типы уже существуют выше.

	Public static void test (String a, int b, double c){}// не будет считаться перегруженным у нас уже есть метод с таким-жи параметрами НО..

	public static void test (double c, int b, String a){}// уже будет являться перегруженным как я и писал последовательность параметров сигнатуры имеет значение.

		Переопределение метода @Override.

	Переопределение является основой полиморфизма одного из ключевых свойств ООП.

	Правила переопределения метода:
*Метод в дочернем классе должен иметь ту-же сигнатуру что и метод в родительском классе.

*Метод в дочернем классе должен иметь тот-же модификатор доступа или шире.

*Возвращаемый тип данных должен быть таким-же как в классе родителя либо быть подклассом этого типа

*Метод в родительском классе метод обьявлен как статик то и в дочернем класе он должен быть статическим( но это уже больше отнести к сокрытию метода... Hiding)

	Примеры:

		Class ParCl{

	protected void test (){}

	String testStr(){return""}

	Number getNumb () {return 1}

	private void test2() {}

	static void test3() {System.out.println ("1")}

		public class Override extends Parcl (
	
	@Override
	public void test () {System.out.println ("aaaaaa")}//переопределение правильное мы рассширили модификатор доступа.

	@Override
	void test() {}/** переопределение неверное в обох случаях модификатор доступа сужен

	@Override
	private test (){}*/

	@Override
	String testStr () {return "Hello"}//эта запись корректна

	@Override
	Integer testStr () {return new Ineger(1)}//нельзя менять тип данных, эта строка выдаст ошибку
	
	@Override
	Double getNumb () {return 10.0}//Double является саб классом Number. Поэтому мы можем вернуть дабл обёртку, в этом случае перопределять методы можно

	@Override
	Pulic void test2 //яркий пример Hiding по правилу вроде запись не корректна.. Но поскольку в классе родителе стоит модификатор private он виден только внутри своего класса таким образом произошло как-бы скрытие метода

	@Override
	static void test3() {System.out.println ("111111")}//запись корректна мы просто переопределили поведение

	@Override
	void test3() {System.out.println ("1")}// запись не корректна нельзя убрать модификатор доступа Static и наоборот


	Так-же преобразования деляться на нисходящие и восходящие..
	Преоброзавание от потомка к предку называються восходящими, а от предка к потомку нисходящие.
	
		class Animal{
    	void doAnimal1(){}
   	 void doAnimal2(){}
				}

	public class Cat extends Animal{

   		 void doCat1(){}
  	 	 void doCat21(){}

  	  public static void main(String[] args) {

      		  Cat cat = new Cat();// здесь мы видим оба метода
     		  cat.doCat1();
      		  cat.doAnimal1();

       	 Animal catA = new Cat(); // восходящее преобразование
     	  catA.doCat1();// этого метода мы не увидим
       	  catA.doAnimal1();

        int i = 125;
        byte b = (byte) i; // нисходящее преобразование (явно нужно указывать тип!)

    }
}

	